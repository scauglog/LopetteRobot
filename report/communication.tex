Dans cette partie nous allons décrire notre approche vis-à-vis de la 
communication série via l'UART.

\subsection{Bufferisation}
Décrivons ce qu'il se passe lors de la réception d'un octet par l'Atmega8. 
Dans un premier temps, une interruption est levé (USART\_RXC\_vect). Nous 
utilisons alors une commande préprocesseur \textit{ISR}, fournie par avr, 
pour redéfinir le comportement de la carte lors de la-dite interruption.
Nous récupérons alors l'octet reçu et le stockons dans un buffer circulaire
de taille prédéfinie. Cette taille a été choisie de sorte qu'elle puisse 
accepter n'importe quelle commande pour notre carte. Ayant un nombre limité
de pin sur notre carte, nous limitons ainsi la taille des données. En 
effet, la commande la plus longue est l'écriture de PWM16 sur l'ensemble
des pins. La taille totale de la trame est alors (en octet) : \\
$$
\begin{array}{ccccccccccc}
1     &+&   2&+&   3&+&  23*2&+&       1&=&53\\
Header&+&Size&+&Mask&+&Values&+&Checksum& &\\
\end{array}
$$
~\\

Dans une première phase de test, ce buffer était lu dans la boucle principal
du main et une réponse était élaborer selon la lettre. Nous allumions une
LED en appuyant sur une touche et l'éteignant en appuyant sur une autre.
Ce comportement à néanmoins changé lorsque nous avons voulu faire à la fois
de PWM logicielle en même temps que la communication sur l'UART.
Cette PWM logicielle a été implémenté est nécessitait un thread pour opérer.
Nous avons alors pensé en créer un de plus avec des bibliothèques de thread
mais en plus de perdre beaucoup d'espace mémoire, nous perdions surtout
l'aspect temps réel de la communication; ce que nous tenons à conserver.
Après quelques essais de ces threads, nous avons donc choisi d'attaquer le
problème autrement. Nous utilisons alors l'interruption pour lancer le parse
de la commande et son éxécution.\\

Cette solution a tout d'abord été émulée avant d'être envoyé sur la carte 
Arduino.

\subsection{Émulation}
Pour émuler les interruptions du processeur nous avons choisi d'utiliser 
la bibliothèque de thread standart. Le code faisant la bufferisation
des caractères à alors été factorisée dans la fonction 
\textit{initiateParse} du \textit{main.c}.\\


%\paragraph{Baud rate :}
%Nous utilisons un baud rate fixé à 115200, ce qui a posé problème au
%début car la formules fournies par la documentation nous donnait une
%valeur fausse (le machine nous renvoyant la partie entière du
%résultat, alors que le micro processeur attendait la valeur arrondie
%pour ce baudrate la).
